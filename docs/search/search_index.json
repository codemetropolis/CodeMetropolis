{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"about/","title":"About","text":"<p>CodeMetropolis is a software visualisation tool. It can create a Minecraft world using the values of source code metrics and the structure of the source code. Thus explore the inner structure of the program or compare several source code elements is easier. CodeMetropolis uses city metaphor for the visualisation of code elements like classes, functions or attributes. The city metaphor is one of the best known metaphors in software visualization. In this metaphor the source code components are represented as a part of a generated city, for example classes represented as buildings or methods represented as floor. It is a set of command line programs, connected into a single toolchain and a couple of supporting plug-ins and scripsts. The first tool is the CDF Converter Tool. This tool creates properties for each item from a graph file, for exmaple functions or methods. The second tool is the Mapping Tool, which processes the output XML file of Converter Tool, assigns metrics to objects of the metropolis and generates an ouput XML that is ready to be used by the Placing Tool. The third tool is Placing Tool. This tool creates the city layout and generates an output XML that is ready to be used by the Render Tool. The last tool is Render Tool. This tool proccesses the ouput XML file of Placing Tool and creates a virtual city in a Minecraft world. CodeMetropolis tools use XML files to communicate with eachother. CDF Converter Tool produces an XML file from the graph file of the source code, then Mapping Tool using the previous XML file generates an ouput XML file which is the input file for the Placing Tool. Then the Placing Tool generates an output XML file for the Rendering Tool. These last two XML files use the same format defined in an XML Schema.</p>"},{"location":"about/#installation-guide","title":"Installation guide","text":"<p>In order to use all functionality of CodeMetropolis you have to install the following dependencies.</p> <ul> <li>Java Runtime Environment 8 to run the command line tools</li> <li>Minecraft client 1.8 to display the Minecraft world</li> <li>SourceMeter to get the graph file, which contains the source code metrics</li> </ul> <p>SourceMeter could be used with the following command:</p> <p><code>SourceMeterJava.exe -projectName=&lt;inputProjectName&gt; -projectBaseDir=&lt;inputProjectDir&gt;</code> <code>-resultsDir=&lt;ResultsDir&gt;</code></p> <p>Options:</p> <ul> <li> <p><code>-projectName=</code>   The name of the project. It will be the name of the directory in the results directory.</p> </li> <li> <p><code>-projectBaseDir=</code>   The path of the directory of the source code.</p> </li> <li> <p><code>-resultsDir=</code>   The path of the directory where the results will be stored.</p> </li> </ul> <p>After that, you can find the graph file in &lt;ResultsDir&gt;&lt;inputProjectName&gt;\\java\\&lt;date&gt;. You can find more information in the documentation of SourceMeter.</p>"},{"location":"about/#cdf-converter-tool","title":"CDF Converter Tool","text":"<p>First you have to run the CDF Converter Tool with the following command:</p> <p><code>java -jar converter.jar -i &lt;graph file&gt; [-o &lt;output.xml&gt;] [-t &lt;tpye&gt;] [-p &lt;parameter&gt;]</code></p> <p>Options:</p> <ul> <li> <p><code>-i</code>: input, the path of the input graph file. Required.</p> </li> <li> <p><code>-o</code>: output, the path of the output XML file.</p> </li> <li> <p><code>-t</code>: type, the type of the conversion. In the current version it can be 'sourcemeter' or 'sonarqube'.</p> </li> <li> <p><code>-p</code>: parameter, a string value, for example: -p projects=project1,project2 splitDirs=true.</p> </li> </ul> <p>Output XML will be used by the Mapping Tool.</p> <p>Details...</p>"},{"location":"about/#mapping-tool","title":"Mapping Tool","text":"<p>Then you have to run Mapping Tool with the following command:</p> <p><code>java -jar mapping.jar -i &lt;inputFile&gt; -o &lt;outputFile&gt; -m &lt;mappingFile&gt;</code></p> <p>Options:</p> <ul> <li> <p><code>-i &lt;path&gt;</code>, <code>--input &lt;path&gt;</code>   Path of the XML file generated by the Converter Tool. Required.</p> </li> <li> <p><code>-o &lt;path&gt;</code>, <code>--output &lt;path&gt;</code>   Output will be generated with the given path. Default: \"mappingToPlacing.xml\".</p> </li> <li> <p><code>-m &lt;path&gt;</code>, <code>--mapping &lt;path&gt;</code>   Path of the input mapping file. Required.</p> </li> </ul> <p>The mapping file contains the parameters of build up the virtual world from the source code. You could find more information about its structure and format in the detailed description of the Mapping Tool. Output XML now should be generated in output directory.</p> <p>Details...</p>"},{"location":"about/#placing-tool","title":"Placing Tool","text":"<p>Second you have to run Placing Tool with the following command:</p> <p><code>java -jar placing.jar -i &lt;inputFile&gt;</code></p> <ul> <li> <p><code>-i &lt;path&gt;</code>, <code>--input &lt;path&gt;</code>   Path of the input XML file. This XML file is generated by Mapping Tool. Required.</p> </li> <li> <p><code>-o &lt;path&gt;</code>, <code>--output &lt;path&gt;</code>   Output will be generated with the given path. Default: \"placingToRendering.xml\".</p> </li> <li> <p><code>-m</code>, <code>--map</code>   Shows the map of the generated metropolis.</p> </li> </ul> <p>Output XML now should be generated in the given output directory.</p> <p>Details...</p>"},{"location":"about/#rendering-tool","title":"Rendering Tool","text":"<p>Then you have to run Rendering Tool with following command::</p> <p><code>java -jar rendering.jar -i &lt;inputFile&gt; -world &lt;worldPath&gt;</code></p> <p>Options:</p> <ul> <li> <p><code>-i &lt;path&gt;</code>, <code>--input &lt;path&gt;</code>   Path of the input XML file. This XML file is generated by the Placing Tool. Required.</p> </li> <li> <p><code>-w &lt;path&gt;</code>, <code>-world &lt;path&gt;</code>   The path of the folder where the world will be placed. Required.</p> </li> </ul> <p>Output world now should be generated in output directory. It may take a long time, depending on the size of the input.</p> <p>Details...</p>"},{"location":"about/#displaying-the-generated-city","title":"Displaying the Generated City","text":"<p>You can find the generated world in the output directory. You have to copy this folder to the \"saves\" folder in root of Minecraft. You can usually find it at \"C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\.minecraft\\\" directory.</p> <p>After that you have to start Minecraft, choose SinglePlayer, then choose the generated world and the selected world will be displayed.</p>"},{"location":"about/#contribution-guide","title":"Contribution guide","text":"<p>This section of the documentation contains a guide for users who would like to contribute code or documentation to the CodeMetropolis project. If you would like to contribute in the project, please send your patches to review. You have to follow the these steps:</p> <ol> <li>Install Git LFS 1.1.0 (or newer) and Git 2.7.0 (or newer).</li> <li>Checkout the <code>develop</code> branch from this repository.</li> <li>Start Eclipse and set the workspace the root directory.</li> <li>Import the project with Existing Maven Projects and the root directory will be the same as the workspace path.</li> <li>Make your changes, improvements or fixes.</li> <li>Create a patch.</li> <li>Post the patch as attachment of a new issue with a description of your contribution.</li> </ol> <p>After that you can run the three tool mentioned above in Eclipse. You have to set the arguments, which is in the Installation Guide section. You can set the arguments in Run Configuration, and run the tools with Run As/Java Application.</p> <p>You can create a jar file with Maven with mvn package command. You have to start command line in toolchain-repository/sources directory and type the command. Then there will be a target directory in every project's directory and this target directory contain the created jar and a lib directory, which is also required to generate cities. It is recommended to copy all jar files to a common directory with the lib directory, which has to contain all lib directory content of each tool.</p>"},{"location":"about/#how-to-use-codemetropolis-with-custom-data-source","title":"How to use CodeMetropolis with custom data source","text":"<p>CodeMetropolis converter logic has been designed to make it easy to visualize data from any source. The toolchain ships with converters for SourceMeter and SonarQube. These tools are great for presenting the structure and metrics of software projects but there might be a bunch of other use cases in which visualization could be very useful. By implementing a custom converter one can build a metropolis based on not just software entities, but any kind of data. This short tutorial will show you how to create your own converter.</p> <p>Details...</p>"},{"location":"contact/","title":"How to contact us?","text":"<p>You could use Github to report an error or suggest new features or improvements. Also feel free to join our CodeMetropolis Google+ Community to leave any other comment or suggestion.</p>"},{"location":"contact/#who-are-we","title":"Who are we?","text":"<p>CodeMetropolis are managed and developed by a small, but enthusiastic team of IT professional. Currently the CodeMetropolis Team consists of the following members.</p> <p>Gerg\u0151 Balogh project manager, developer \u00a0View Gerg\u0151 Balogh's profile</p> <p>Attila Szabolics developer \u00a0View Attila Szabolics's profile</p> <p>Erika Bord\u00e1s developer \u00a0View Erika Bord\u00e1s's profile</p> <p>Rita B\u00e1rtfai designer, documentation writer and tester \u00a0View Rita B\u00e1rtfai's profile</p>"},{"location":"custom/","title":"Custom CDF Converter Tutorial","text":"<p>Converters are responsibly for turning data into a CDF (Common Data Format) file which can be used as the input of the mapping component. CDF uses a simple XML-based syntax as it is described here. Fortunately, the CodeMetropolis toolchain already provides a few classes which help developers to deal with CDF files. I will talk about these soon.</p> <p>Basically, there are two ways to implement a converter: to expand the codemetropolis-toolchain-converter project, or to create your own separated converter project. This tutorial will guide you through the first method as it is the recommended way if you are willing to share your converter with the community.</p> <p>The first thing you have to do is to checkout the CodeMetropolis Git repository and load the Maven projects into Eclipse. For more information on this please read the contribution guide. You need to add a new package to the <code>codemetropolis-toolchain-converter project</code>. Its name should be <code>codemetropolis.toolchain.converter.&lt;name&gt;</code> by convention where  is the name of the converter containing only lowercase letters of English alphabet. Please stick to our naming conventions if you are planning to send a patch to us. I am going to call mine <code>MyCustomConverter</code> for the rest of this tutorial so in this case our package is <code>codemetropolis.toolchain.converter.mycustom</code>. <p>Now it\u2019s time to create the main component of the converter. Create a new class, name it <code>MyCustomConverter</code> and place it in the package you\u2019ve just created. Make this class extend <code>codemetropolis.toolchain.commons.cdf.converter.CdfConverter</code>. You also have to override an abstract method:</p> <pre><code>public class MyCustomConverter extends CdfConverter {\n\n  public MyCustomConverter(Map&lt;String, String&gt; params) {\n    super(params);\n  }\n\n  @Override\n  public CdfTree createElements(String source) {\n    //implement conversion logic here\n  }\n\n}\n</code></pre> <p>This method is used to construct the structure of the output CDF document. The <code>source</code> parameter holds the path to the source of the data you want to convert and is passed as command line argument (or executor argument when using the CodeMetropolis API). This could be for example a file or a server, but you are free to use any kind of data source. The implementation should load the data from the source, create the CDF elements and place them in a tree structure. The method must return a <code>CdfTree</code> object which holds the (no surprise) CDF tree. All CDF related classes are placed in a package named <code>codemetropolis.toolchain.commons.cdf</code>. Since we will need all of these, we can import them like:</p> <pre><code>import codemetropolis.toolchain.commons.cdf.*;\n</code></pre> <p>The data conversion logic fully depends on the data source and your own purposes, therefore I will only explain the creation of the CDF structure. To compose the <code>CdfTree</code>, first you have to transform your data into <code>CdfElement</code> objects. A <code>CdfElement</code> represents a data object with a name, a type, and a bunch of properties. All elements in a CdfTree must connect to each other through parent-child relations. There must be a single root element with no parent. Every other element must have exactly one parent and any number of children. You can construct an element as follows:</p> <pre><code>CdfElement element = new CdfElement(\"name\", \"type\");\nelement.addProperty(\"property_1\", \"value\", CdfProperty.Type.STRING);\nelement.addProperty(\"property_2\", \"10\", CdfProperty.Type.INT);\nelement.addProperty(\"property_3\", \"3.14\", CdfProperty.Type.FLOAT);\nelement.addChildElement(otherElement);\n</code></pre> <p>When you finished creating your <code>CdfElement</code> objects you have to place them in a <code>CdfTree</code>. To achieve this, you only need call the constructor of the <code>CdfTree</code> class passing the root <code>CdfElement</code> as an argument. Then you can simply return the newly created object.</p> <pre><code>return new CdfTree(rootElement);\n</code></pre> <p>The conversion might need some custom parameters coming for command line arguments. You can access these with the <code>getParameter(\"parameter_id\")</code> method. In command line the syntax of custom parameters are the following:</p> <p><code>-p parameter1=value1 parameter2=value2 [\u2026]</code></p> <p>During the conversion process you might also want to print some information to the output stream (console when using with command line). You can do that by calling <code>fireConverterEvent(\"your message\")</code>.</p> <p>By now, you have already implemented the data conversion logic. The last thing to do is to register your converter so it becomes accessible as a valid converter type. Look up the <code>codemetropolis.toolchain.converter.control</code> package and open the <code>ConverterType</code> enum for editing and add name of your converter to the list:</p> <pre><code>public enum ConverterType {\n    SOURCEMETER,\n    SONARQUBE,\n    MYCUSTOM\n}\n</code></pre> <p>Now open the <code>ConverterLoader</code> class and add a new case statement to the load method:</p> <pre><code>public static CdfConverter load(ConverterType converterType, Map&lt;String, String&gt; params) {\n    switch(converterType) {\n        case SOURCEMETER:\n            return new GraphConverter(params);\n        case SONARQUBE:\n            return new SonarQubeConverter(params);\n        case MYCUSTOM:\n            return new MyCustomConverter(params);\n        default:\n            return null;\n    }\n}\n</code></pre> <p>That\u2019s all. Now you can use your converter just like the default converters:</p> <p><code>java -jar converter.jar -t mycustom -s &lt;source&gt; -o &lt;output_xml&gt;</code></p>"},{"location":"research/","title":"First steps","text":"<p>Our main contribution with the CodeMetropolis is to connect data visualisation with hight end-user graphic capabilities. This tool processes the basic source code metrics as input and generates a MineCraft world with buildings, districts and gardens. The tool in 2013, represented at first time on a conference was in prototype state. This version was written in C# using the .Net framework. It is a command line tool which takes the previously mentioned graph as input and creates a Minecraft world from it. There are a couple of open-source API-s for every major language which support editing or creations over these worlds. Our tool uses the Substrate library for .NET Framework.</p> <p>The representation has two main levels. On the data level, each entity has its own property set \u2013 for example metrics. In the current version, these are loaded from the previously mentioned graph, but we plan to support other data sources, for example XML files. These data are displayed on the metaphor level. All buildings in the metropolis belong to this. The buildings and the world itself has a couple of attributes which control visual appearance. The properties are mapped to the attributes in order to visualise the data. However, in the current version this mapping is hardcoded, the further versions will support customisation with a sophisticated mapping language.</p> <p>CodeMetropolis implements multilevel data visualisation: Minecraft allows fly, seeing the large scale size of classes and namespaces. Users can walk on the streets and compare the size and the complexity of the methods. It is possible to go inside the methods.</p> <p>CodeMetropolis implements multilevel data visualisation: Minecraft allows fly, seeing the large scale size of classes and namespaces. Users can walk on the streets and compare the size and the complexity of the methods. It is possible to go inside the methods.</p>"},{"location":"research/#benefits-and-other-future-possibilities","title":"Benefits and other future possibilities","text":"<ul> <li>Bad smells detection</li> <li>Inspect the structure of code</li> <li>Extending the palette of the entities and attributes: The future version of our converter will use an extended palette of the blocks supported in Minecraft. For example, flowers to decorate beautiful code and zombies (hostile creatures) to indicate bad practices. In addition according to our plans it will be possible explore inner structure of methods with furniture.</li> <li>Inter-user communication: Besides the traditional forms of communication like textual chat and audio connection users will be able to use in-game items and techniques to interact with each other. For example, they could leave signs as notification or if they are walking together in the virtual world they could simply point to or go to a specific part of the \u201ccode\u201d.</li> <li>Understanding inter-metrical relations: CodeMetropolis will use various sophisticated metaphors. For example, a floor represents a method. Its width and length are mapped to its complexity and its height indicates its size. Furthermore, the number of windows and doors visualise the count of its parameters.</li> <li>Round-trip source code management: The changes between the source code and the metropolis will be propagated to each other.</li> <li>Support code annotation: When developers are inspecting the source code, they could leave comments to mark its parts. A future version of our conversion tool will support code annotation. When developers put a wall or post a sign on some entities (floors, buildings) the text on it will be inserted into the source code as a comment. (Planned before)</li> <li>Present code history gathered from the version controlling system.</li> <li>Identify tested code: For example, torches and glowstones can be used to illuminate the building representing the tested parts of the code.</li> <li>Understanding inter-metrical relations: CodeMetropolis will use various sophisticated metaphors. For example, a floor represents a method. Its width and length are mapped to its complexity and its height indicates its size. Furthermore, the number of windows and doors visualise the count of its parameters.</li> <li>In-game explanations: Post and wall sings and books will be used to explain the meaning of the various attributes and to show the source code of the corresponding element.</li> <li>Navigation support: We plan to implement a mini-map and a teleportation system. The related classes will be connected with railways allowing the users to navigate and see the connections.</li> </ul> <p>Negative opinios:</p> <ul> <li>Great distances. The metropolis of a large or medium scale project can be huge and the players need a lot of time to navigate in it. We plan to solve this problem by implementing a quick map and a navigation system.</li> <li>Learning curves.</li> <li>The last problem was the lack of simultaneous data visualisation. The users could identify only three attributes: width, length, and height. This limited set is not enough to visualise the complex items of the data level.</li> </ul> <p>In this year we represent CodeMetropolis on VISSOFT conference too.</p>"},{"location":"research/#move-forward-with-creating-eclipse-plug-in","title":"Move forward with creating Eclipse plug-in","text":"<p>In 2015 we developed a new version of CodeMetropolis, with the users can invoke the visualization directly from the IDE. The new version of the tool now includes an Eclipse plug-in and a MineCraft modification in addition to the analysis and visualization modules, which have also been extended with some new features. Our goal was to build a bridge between coding and visualization. We chose Eclipse among the IDEs because it was a common tool for Java developers. We implemented a set of plugins which was able to connect Eclipse and CodeMetropolis, hence it became capable of integrating an elaborated visualization technique without disturbing the daily routine of developers. This version was presented in 2015 on SCAM conference.</p> <p>In this new version of CodeMetropolis, data visualization has four phases: filtering, mapping, rendering, and displaying.</p> <p></p>"},{"location":"research/#modifications","title":"Modifications","text":"<p>The implementation has three interlinked components. The first is Eclipse, the IDE itself, the second is Minecraft, which displays the generated city, and SourceMeter, a static code analyzer, which provides the metrics and the structures of the source code. These are connected via CodeMetropolis that converts the data to visual representation using the given mapping and city metaphor. Since the 2013 release of CodeMetropolis toolkit, it has undergone significant changes. A new placing algorithm has been implemented to provicee a more optimal city layout. A brand new build system has also been addid which resulted 100 times faster block creation. The mapping format has been completely redesigned to provice a a cleaner syntex and a lot more options. The background logic of the toolkit had to be changed at multiple points to fit our intentions.</p> <p></p> <p>Minecraft modifications:</p> <ul> <li>Synchronizing: to prevent any concurrent modification with the game, it disables the user interface while building the generated city. After the conversion the target world is reloaded. We also provide informative messages to notify the user about the state of the process.</li> <li>Positioning the player: it allows the external processes to set the position and orientation of the player.</li> </ul>"},{"location":"wall-of-fame/","title":"Contributors","text":"<p> University of Szeged Department of Software Engineering Szeged, Hungary</p>"},{"location":"wall-of-fame/#supporter","title":"Supporter","text":"<p> FrontEndART Ltd. Szeged, Hungary</p>"},{"location":"toolchain/converter/","title":"Sourcemeter CDF conversion","text":"<p>This application using sourcemeter as type is used to process the graph file generated by SourceMeter, which creates properties for each item, for exmaple functions that will be processed later by the Mapping Tool.</p> <p>Usage: <code>java -jar converter.jar -t &lt;tpye&gt; -i &lt;graph file&gt; [-o &lt;output.xml&gt;]  [-p &lt;parameter&gt;]</code></p> <ul> <li><code>-i</code>: input, the path of the input graph file. Required.</li> <li><code>-o</code>: output, the path of the output XML file. Optional.</li> <li><code>-t</code>: type, the type of the conversion, in this case it will be \u2018sourcemeter\u2019. Required.</li> <li><code>-p</code>: parameter, a string value, for example: -p projects=project1,project2. Regex expressions are allowed to use in project names.</li> </ul> <p>As we mentioned, projects can also be defined with regex expression, for example if you would like to convert all projects start with \"a\" letter, use projects=^a.*. In these expressions comma (,) and equal sign (=) are forbidden. Regular expression special characters must be escaped even if you are providing a simple project name: for example if the project name is \"project.java\", you should type it projects=project.java.</p> <p>After executing the tool a Converter output xml will be generated, which contains package, class, attribute, method and constant elements with different properties.</p>"},{"location":"toolchain/converter/#sonarqube-cdf-conversion","title":"SonarQube CDF conversion","text":"<p>This application using sonarqube as type is used to process one or more projects from a SonarQube server, which creates properties for each item, for exmaple files that will be processed later by the Mapping Tool. The Tool works properly only with 5.3 version of SonarQube.</p> <p>Usage: <code>java -jar converter.jar -t &lt;tpye&gt; -i &lt;graph file&gt; [-o &lt;output.xml&gt;]  [-p &lt;parameter&gt;]</code></p> <ul> <li><code>-i</code>: input, the URL of the server.</li> <li><code>-o</code>: output, the path of the output XML file. Optional.</li> <li><code>-t</code>: type, the type of the conversion. In this case it will be \u2018sonarqube\u2019. Required.</li> <li><code>-p</code>: parameter, a string value, for example: -p projects=project1,project2. Parameters can be 'username', 'password', 'projets', 'splitDirs'. Regex expressions are allowed to use in project names.</li> </ul> <p>After executing the tool a Converter output xml will be generated, which contains project, directory and file elements.</p> <p>Parameters</p> <p>In some cases reaching the SonarQube server requires authentication. The user can parameterize the command giving username and password, for example '-p username=user password=Zt323Kl'.</p> <p>There is a projects option, where user can define the buildable projects, for example '-p projects=log4j,cm2'. If the user leave this option, all project of the server will be converted. Projects should be given separated by commas.</p> <p>There is a boolean splitDirs option, which can be given in the -p parameter too. In case of splitDirs=false, the name of the directory will complex, and only one element, for example:</p> <pre><code>&lt;element name=\"sources/codemetropolis-toolchain-commons/src/main/java/codemetropolis/toolchain/commons/cmxml\" type=\"dir\"&gt;\n</code></pre> <p>When splitDirs=true, all part of the directory will be a uniq dir element. In the following example there are two different city built from the same project using splitDirs=false and then splitDirs=true.</p> <p></p> <p>To build a city with separated directories, the following command should be given to run Converter Tool:</p> <p><code>java -jar converter.jar -t sonarqube -i &lt;serverName&gt; -o &lt;outputFilename&gt; -p projects=&lt;projectname&gt; splitDirs=true</code></p>"},{"location":"toolchain/converter/#about-the-output-xml","title":"About the output XML","text":"<p>The output XML contains the name and the type of the elements and the properties of them.</p> <pre><code>&lt;element name=\"void main(String[] args)\" type=\"method\"&gt;\n    &lt;children/&gt;\n       &lt;properties&gt;\n           &lt;property name=\"sourceid\" type=\"string\" value=\"L118\"/&gt;\n           &lt;property name=\"Name\" type=\"string\" value=\"void main(String[] args)\"/&gt;\n           &lt;property name=\"LongName\" type=\"string\" value=\"URLExpSimple.main([Ljava/lang/String;)V\"/&gt;\n           &lt;property name=\"CLLC\" type=\"float\" value=\"0.0\"/&gt;\n           &lt;property name=\"CC\" type=\"float\" value=\"0.0\"/&gt;\n           &lt;property name=\"CI\" type=\"int\" value=\"0\"/&gt;\n           &lt;property name=\"CCL\" type=\"int\" value=\"0\"/&gt;\n           &lt;property name=\"CCO\" type=\"int\" value=\"0\"/&gt;\n           &lt;property name=\"LLDC\" type=\"float\" value=\"0.0\"/&gt;\n</code></pre> <p>In the represented XML source a method type element called \"void main(String[] args)\" with several properties are shown. Every property has a name, a type and a value. Type can be string, float or int.</p>"},{"location":"toolchain/interXMLformat/","title":"Inter tool XML format","text":"<p>CodeMetropolis tools are using XML files to communicate with each other. Mapping Tool generates an output XML file which is used by placing tool as input. Similarly, the Placing Tool creates an XML for Rendering Tool. These XML files are using the same format defined in an XML Schema. Here is an exmaple from a placing output XML:</p> <pre><code>&lt;children&gt;\n    &lt;buildable id=\"L168\" name=\"WordCount\" type=\"garden\"&gt;\n        &lt;position x=\"9\" y=\"62\" z=\"70\"/&gt;\n        &lt;size x=\"40\" y=\"139\" z=\"25\"/&gt;\n        &lt;attributes&gt;\n              &lt;attribute name=\"flower-ratio\" value=\"0.0\"/&gt;\n        &lt;/attributes&gt;\n        &lt;children&gt;\n            &lt;buildable id=\"L237\" name=\"void performExp()\" type=\"floor\"&gt;\n                 &lt;position x=\"16\" y=\"128\" z=\"77\"/&gt;\n                 &lt;size x=\"9\" y=\"17\" z=\"11\"/&gt;\n                 &lt;attributes&gt;\n                         &lt;attribute name=\"external_character\" value=\"metal\"/&gt;\n                         &lt;attribute name=\"character\" value=\"glass\"/&gt;\n                         &lt;attribute name=\"torches\" value=\"1\"/&gt;\n                 &lt;/attributes&gt;\n</code></pre> <p><code>Buildable</code> tags are representing objects of the city, which are located in hierarchical structure. These objects have some parameters with specific meaning:</p> <ul> <li>id: identifies buildable, for example \"L176\".</li> <li>name: name of the buildable, it can be a method, a function etc.</li> <li>type: buildable type can be ground, garden, floor or cellar.</li> <li>position: position of buildable by x, y and z coordinates.</li> <li>size: size of buildable by x, y and z length. Size can be only a positive integer number.</li> <li>attributes: all additional attributes like the material the object is made of. It has a name and a value parameter, for example name=\"character\", value=\"glass\".</li> <li>children: to represent the hierarchy, some buildables can contain additional buildables. That means the \"child\" object is part of the \"parent\". Grounds can contain grounds or houses and houses can contain floors or cellars. No other relation is allowed.</li> </ul> <p>Mapping to Placing XML contains only the structure of the city, the attributes of it and the size of inner buildings like floor or cellar, while Placing to Rendering XML defines the position and the size of all buildings.</p> <p>During placing phase, the position of simple elements (which does not contain any other element) are set and the size of the compound elements are calculated and propagated up along the containment relation. Of course the position of the compound elements are also updated. For example in a garden place (set the position of) two floors in the two opposite corner, then the garden should scaled up (set the size) to be able to contain these floors.</p> <p>These XMLs are built up on the same XML schema.</p>"},{"location":"toolchain/mapping/","title":"Mapping Tool","text":"<p>This application is used to process the XML file generated by the CDF Converter Tool, assigns metrics to objects of the metropolis and generates an output XML that is ready to be used by CodeMetropolis Placing Tool. The tool is using the mapping file to link source code elements and metrics to world objects. For example, link of the LOC metric is related to the height of the building. The source tag contains the metric that will be a link to the object, the name parameter is the element of the source code and the from parameter is the metric. The target parameter is the world object, the name parameter is the name of the element in the city and the to parameter is the property of the element. If the value of the metric doesn't fit the world element, you have to use conversion.</p> <p>Usage: <code>java -jar mapping.jar -i &lt;inputFile&gt; -m &lt;mappingFile&gt; [-o &lt;outputFile&gt;]</code></p> <p>Command line options:</p> <ul> <li><code>-h</code>: help, shows the usage of the command line tool.</li> <li><code>-i</code>: input, the path of the input XML file generated by the Converter Tool. Required.</li> <li><code>-o</code>: output, which will be generated to the given path. Default: \"mappingToPlacing.xml\".</li> <li><code>-m</code>: mapping, path of the input mapping file. Required.</li> <li><code>-s</code>: scale. Set the scale of blocks. Default: 1.0</li> <li><code>-v</code>: validate. Default: false. In case of true, the tool will validate the generated structure elements, if it's false, the invalid structure elements will be thrown.</li> </ul> <p>About the mapping file</p> <p>Mapping tool uses an XML file to determine the bindings from source elements to buildings of the world. Editing this file allows you to use the city metaphors the way you want. Mapping XMLs must follow a specific format.</p> <pre><code>&lt;linking source=\"method\" target=\"floor\"&gt;\n    &lt;binding from=\"LLOC\" to=\"height\"/&gt;\n    &lt;binding from=\"NII\" to=\"width\"/&gt;\n    &lt;binding from=\"NOI\" to=\"length\"/&gt;\n    &lt;binding from=\"McCC\" to=\"character\"&gt;\n        &lt;conversions&gt;\n            &lt;conversion type=\"quantization\"&gt;\n                &lt;parameter name=\"level0\" value=\"glass\"/&gt;\n                &lt;parameter name=\"level1\" value=\"sand\"/&gt;\n                &lt;parameter name=\"level2\" value=\"planks\"/&gt;\n                &lt;parameter name=\"level3\" value=\"stone\"/&gt;\n                &lt;parameter name=\"level4\" value=\"obsidian\"/&gt;\n            &lt;/conversion&gt;\n        &lt;/conversions&gt;\n    &lt;/binding&gt;\n&lt;/linking&gt;\n</code></pre> <p>In the <code>&lt;linking&gt;</code> tag it can be set how a program element should be displayed in the world. The <code>source</code> must be an existing type of the input CDF, while the <code>target</code> specifies the building type to which the source will be linked to. The valid building types are the following: <code>ground</code>, <code>garden</code>, <code>floor</code>, <code>cellar</code>.</p> <p>The bindings are used to tell the mapping component which properties of the source element to bind to which attribute of the target object. The table below shows the currently supported attributes.</p> attribute type targets description width integer floor, cellar size near X height integer floor, cellar size near Y length integer floor, cellar size near Z character* string floor, cellar primary material the structure is made of external_character* string floor, cellar secondary material the structure is made of torches integer (0 to 5) floor, cellar quantity of torches, bigger value means smaller spaces between torches flower-ratio float (0 to 1) garden quantity of flowers tree-ratio float (0 to 1) garden quantity of trees mushroom-ratio float (0 to 1) garden quantity of mushrooms <p>*supported values: stone, cobblestone, mossy_stone, sandstone, obsidian, wood, dark_wood, birch_wood, planks, dark_planks, metal, dirt, sand, red_sand, brick, stone_brick, dark_brick, glass, gold, diamond</p> <p>Sometimes a source value doesn't fit the world element we use as target. In this case, we use conversions. At the moment, the following conversions are available:</p> <ul> <li><code>to int</code></li> <li><code>quantization</code></li> <li><code>normalize</code></li> <li><code>switch</code></li> </ul> <p>The next example show a quantization conversion.</p> <pre><code>&lt;conversion type=\"quantization\"&gt;\n    &lt;parameter name=\"level0\" value=\"1\"/&gt;\n    &lt;parameter name=\"level1\" value=\"2\"/&gt;\n&lt;/conversion&gt;\n</code></pre>"},{"location":"toolchain/placing/","title":"Placing Tool","text":"<p>This application is used to create the city layout and generate an output XML that is ready to be used by CodeMetropolis Render Tool.</p> <p>Usage: <code>java \u2013jar placing.jar \u2013i &lt;inputFile&gt; [-o &lt;outputFile&gt;] [-m]</code></p> <p>Command line options:</p> <ul> <li><code>-h</code>: help, shows basic info.</li> <li><code>-i</code>: input, input from this file. Exactly this is the path of the input XML file, which is generated by the Mapping Tool. Required.</li> <li><code>-o</code>: output, output to this file. Output will be generated to the given path. Default: \u201cplacingToRendering.xml\u201d. Optional.</li> <li><code>-l</code>: layout, layout algorithm. Layout can be PACK or TETRIS. Optional. Default value is PACK.</li> <li><code>-m</code>: map, whether or not the map should be shown.</li> </ul> <p>If we use the <code>\u2013m</code> option, the following popup window will appear:</p> <p></p> <p>On the map the structure of the virtual city is represented, generated from the source code. Different colors represent different types of objects.</p> Colors Objects orange ground blue garden green floor red cellar <p>After closing this window, the building process will be finished.</p> <p>The input of Placing Tool contains only the structure and the main attributes of the city, while the output XML describes the size of inner buildings, like floor and cellar. Here is an example:</p> <p>Part of mappingToPlacing.xml:</p> <pre><code>&lt;buildable id=\"8b224e44-26f8-4ab3-94b0-7831238e3d7a\" name=\"void performExp()\" type=\"floor\"&gt;\n    &lt;position x=\"0\" y=\"0\" z=\"0\"/&gt;\n    &lt;size x=\"9\" y=\"17\" z=\"11\"/&gt;\n    &lt;attributes&gt;\n        &lt;attribute name=\"external_character\" value=\"metal\"/&gt;\n        &lt;attribute name=\"character\" value=\"glass\"/&gt;\n        &lt;attribute name=\"torches\" value=\"1\"/&gt;\n    &lt;/attributes&gt;\n    &lt;children/&gt;\n&lt;/buildable&gt;\n</code></pre> <p>In the <code>buildable</code> tag there is an id, a name and a type, which defines the the buildable object, for example a method. <code>Position</code> tag defines the place of the object, and the <code>size</code> specify the size of the object. Every object can have attributes.</p> <p>Part of placingToRendering.xml:</p> <pre><code>&lt;buildable id=\"8b224e44-26f8-4ab3-94b0-7831238e3d7a\" name=\"void performExp()\" type=\"floor\"&gt;\n    &lt;position x=\"26\" y=\"63\" z=\"76\"/&gt;\n    &lt;size x=\"9\" y=\"17\" z=\"11\"/&gt;\n    &lt;attributes&gt;\n        &lt;attribute name=\"external_character\" value=\"metal\"/&gt;\n        &lt;attribute name=\"character\" value=\"glass\"/&gt;\n        &lt;attribute name=\"torches\" value=\"1\"/&gt;\n    &lt;/attributes&gt;\n    &lt;children/&gt;\n&lt;/buildable&gt;\n</code></pre> <p>In placingToRendering.xml a buildable object has got the same parameters and attributes, only the position will be exactly specified in addition.</p>"},{"location":"toolchain/rendering/","title":"Rendering Tool","text":"<p>This application is used to process the output of CodeMetropolis Placing Tool and create a virtual city in a Minecraft world. Basicly it generates the descriptions of blocks and makes a Minecraft world of them.</p> <p>Usage: <code>java \u2013jar rendering.jar \u2013i &lt;inputFile&gt; -w &lt;WorldPath&gt; [-s]</code></p> <p>Command line options:</p> <ul> <li><code>-h</code>: help, shows basic info.</li> <li><code>-i</code>: input, input from this file. Exactly this is the path of the input XML file, which is generated by the Placing Tool. Required.</li> <li><code>-w</code>: world, the location and the name of the world, which will be generated to the given path.</li> <li><code>-s</code>: silent, which means silently overwriting. In the case of an existing world, if this parameter is false, the program will ask the user, does he or she want to overwrite the existing world, and if the silent parameter is true, exactly if it is given, the program will overwrite the existing world without asking.</li> </ul> <p>Here is an example that describes which visual object represents different code elements:</p> <p></p> <p>For example, the height of a building represents the lines of code of a method, and the width means the McCabe complexity of it:</p> <p></p>"}]}